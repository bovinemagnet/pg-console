= Testing
Paul Snow
0.0.0
:description: Testing strategy for pg-console including unit tests, integration tests, E2E tests, and coverage
:keywords: testing, unit tests, integration tests, Testcontainers, Playwright, JaCoCo

include::_attributes.adoc[]

This page describes the testing strategy for pg-console, including how to run tests, write new tests, and measure code coverage.

== Testing Philosophy

pg-console follows a comprehensive testing strategy to ensure reliability and maintainability:

* *Unit tests* validate individual components in isolation
* *Integration tests* verify interactions with PostgreSQL using Testcontainers
* *End-to-end tests* validate the full user experience using Playwright
* *Code coverage* measures test effectiveness with JaCoCo
* *CI/CD pipeline* runs all tests automatically on every commit

The test suite is designed to run quickly, provide fast feedback, and catch regressions early.

== Test Database Strategy

pg-console uses different database strategies for different types of tests to balance speed, compatibility, and developer convenience.

=== Current Approach

* *Unit tests* use H2 in-memory database for fast execution without requiring Docker
* *Integration tests* requiring PostgreSQL-specific features use Testcontainers with real PostgreSQL instances
* *Integration tests* that don't require PostgreSQL system catalogs can run on H2 for speed

This hybrid approach optimises test execution time whilst ensuring PostgreSQL-specific functionality is properly validated.

=== H2 Limitations

H2 is a fast, lightweight in-memory database, but it doesn't support PostgreSQL-specific features:

* *System catalogues* - `pg_stat_activity`, `pg_stat_statements`, `pg_settings`, `pg_locks`, `pg_stat_database` are not available
* *PostgreSQL functions* - PostgreSQL-specific functions and operators may behave differently or fail
* *Extensions* - `pg_stat_statements` and other extensions cannot be loaded
* *Data types* - Some PostgreSQL data types and type behaviours differ in H2

Tests that require these features will fail with H2 and should use Testcontainers with the `@QuarkusTestResource(PostgresTestResource.class)` annotation.

=== When to Use Each Strategy

.Database Strategy Decision Matrix
[cols="1,2,1"]
|===
|Test Type |Database Choice |Rationale

|Service layer unit tests
|H2 in-memory
|Fast, no external dependencies needed

|Repository tests (CRUD only)
|H2 in-memory
|Simple SQL works fine on H2

|Repository tests (pg_stat_*)
|Testcontainers PostgreSQL
|Requires PostgreSQL system catalogues

|REST endpoint tests (basic)
|H2 in-memory
|Faster feedback, no Docker required

|REST endpoint tests (full features)
|Testcontainers PostgreSQL
|Full PostgreSQL compatibility

|E2E tests
|Testcontainers PostgreSQL
|Tests production-like environment
|===

=== Future Improvements

The following improvements are under investigation to enhance the test database strategy:

*Testcontainers for All Integration Tests*::
Migrate all integration tests (including `ApiResourceIT`) to use the existing `IntegrationTestProfile` with Testcontainers. This would provide full PostgreSQL compatibility across all tests but requires Docker to be running for all test executions. This trade-off between speed and compatibility may be worth it for consistent behaviour.

*Embedded PostgreSQL*::
Investigate using embedded PostgreSQL libraries (e.g., `io.zonky.test:embedded-postgres`) for in-process PostgreSQL without Docker. This could provide:
+
* Better PostgreSQL compatibility than H2
* Faster startup than Testcontainers
* No Docker dependency for developers
* Support for PostgreSQL system catalogues and extensions
+
This approach would combine the speed benefits of in-memory databases with the compatibility benefits of real PostgreSQL.

*Selective Test Execution*::
Consider adding test tags (e.g., `@RequiresPostgreSQL`, `@RequiresDocker`) to enable developers to run fast tests without Docker during development, whilst CI/CD pipelines run the full test suite with Testcontainers.

== Test Structure

Tests are organised in `src/test/java/` following the same package structure as the main codebase:

[source,text]
----
src/test/java/com/bovinemagnet/pgconsole/
├── model/        # Model/DTO validation tests
├── repository/   # Repository integration tests
├── resource/     # REST endpoint tests
├── service/      # Service layer unit and integration tests
└── e2e/          # End-to-end Playwright tests
----

=== Test Naming Conventions

* Test classes end with `Test`: `PostgresServiceTest`, `HistoryRepositoryTest`
* Test methods use descriptive names: `shouldReturnSlowQueriesOrderedByTotalTime()`
* Integration tests end with `IT`: `HistoryRepositoryIT`, `DashboardResourceIT`
* E2E tests end with `E2E`: `DashboardNavigationE2E`, `AutoRefreshE2E`

== Running Tests

=== All Tests

Run the entire test suite:

[source,bash]
----
gradle21w test
----

This executes:

* Unit tests (fast, no external dependencies)
* Integration tests (slower, uses Testcontainers)
* E2E tests (slowest, uses Playwright)

=== Unit Tests Only

Run only fast unit tests:

[source,bash]
----
gradle21w test --tests '*Test' --exclude-task testE2E
----

=== Integration Tests Only

Run only integration tests with Testcontainers:

[source,bash]
----
gradle21w test --tests '*IT'
----

=== E2E Tests Only

Run only end-to-end Playwright tests:

[source,bash]
----
gradle21w testE2E
----

=== Single Test Class

Run a specific test class:

[source,bash]
----
gradle21w test --tests PostgresServiceTest
----

=== Single Test Method

Run a specific test method:

[source,bash]
----
gradle21w test --tests PostgresServiceTest.shouldReturnSlowQueriesOrderedByTotalTime
----

=== Continuous Testing

Run tests automatically when files change (development mode):

[source,bash]
----
gradle21w test --continuous
----

== Unit Tests

Unit tests validate individual components in isolation without external dependencies.

=== Service Layer Tests

Service layer tests use mocking to isolate business logic from data access.

[source,java]
----
@QuarkusTest
class SparklineServiceTest {

    @Inject
    SparklineService sparklineService;

    @Test
    void shouldGenerateSvgSparklineFromDataPoints() {
        // Given
        List<Double> values = List.of(10.0, 20.0, 15.0, 30.0, 25.0);

        // When
        String svg = sparklineService.generateSparkline(values, 100, 30);

        // Then
        assertThat(svg).contains("<svg");
        assertThat(svg).contains("<polyline");
        assertThat(svg).contains("width=\"100\"");
        assertThat(svg).contains("height=\"30\"");
    }

    @Test
    void shouldHandleEmptyDataGracefully() {
        // Given
        List<Double> values = List.of();

        // When
        String svg = sparklineService.generateSparkline(values, 100, 30);

        // Then
        assertThat(svg).contains("<svg");
        assertThat(svg).doesNotContain("<polyline");
    }
}
----

=== Model Validation Tests

Model tests validate DTOs, records, and data structures:

[source,java]
----
class SlowQueryTest {

    @Test
    void shouldCreateSlowQueryRecord() {
        // Given/When
        SlowQuery query = new SlowQuery(
            123456789L,
            "SELECT * FROM users WHERE id = $1",
            1000L,
            5000.0,
            5.0,
            "postgres"
        );

        // Then
        assertThat(query.queryId()).isEqualTo(123456789L);
        assertThat(query.calls()).isEqualTo(1000L);
        assertThat(query.totalTime()).isEqualTo(5000.0);
    }

    @Test
    void shouldCalculateMeanTimeCorrectly() {
        // Given
        SlowQuery query = new SlowQuery(
            123456789L, "SELECT 1", 1000L, 5000.0, 5.0, "postgres"
        );

        // When
        double meanTime = query.totalTime() / query.calls();

        // Then
        assertThat(meanTime).isEqualTo(5.0);
    }
}
----

=== Utility and Helper Tests

Test utility classes and helper methods:

[source,java]
----
class AllowlistValidatorTest {

    private static final Set<String> ALLOWED_COLUMNS = Set.of(
        "query", "calls", "total_time", "mean_time"
    );

    @Test
    void shouldAllowValidColumn() {
        String column = "total_time";
        boolean valid = ALLOWED_COLUMNS.contains(column);
        assertThat(valid).isTrue();
    }

    @Test
    void shouldRejectInvalidColumn() {
        String column = "malicious_column; DROP TABLE users--";
        boolean valid = ALLOWED_COLUMNS.contains(column);
        assertThat(valid).isFalse();
    }
}
----

== Integration Tests

Integration tests verify interactions with PostgreSQL using Testcontainers to provide a real database.

=== Testcontainers Setup

Testcontainers automatically starts a PostgreSQL Docker container for integration tests:

[source,java]
----
@QuarkusTest
@QuarkusTestResource(PostgresTestResource.class)
class HistoryRepositoryIT {

    @Inject
    HistoryRepository historyRepository;

    @Test
    void shouldInsertAndRetrieveOverviewHistory() {
        // Given
        OverviewHistory sample = new OverviewHistory(
            null,
            Instant.now(),
            10,
            5,
            3,
            0,
            95.5,
            1024000L,
            100.0,
            1000L,
            500L,
            100L
        );

        // When
        historyRepository.insertOverviewHistory(sample);
        List<OverviewHistory> results = historyRepository
            .getOverviewHistory(Duration.ofHours(1));

        // Then
        assertThat(results).hasSize(1);
        assertThat(results.get(0).totalConnections()).isEqualTo(10);
        assertThat(results.get(0).cacheHitRatio()).isEqualTo(95.5);
    }

    @Test
    @Transactional
    void shouldDeleteOldRecords() {
        // Given
        Instant oldTime = Instant.now().minus(Duration.ofDays(10));
        OverviewHistory oldSample = new OverviewHistory(
            null, oldTime, 5, 3, 2, 0, 90.0, 1024000L, 50.0, 500L, 200L, 50L
        );
        historyRepository.insertOverviewHistory(oldSample);

        // When
        int deleted = historyRepository.deleteOldRecords(Duration.ofDays(7));

        // Then
        assertThat(deleted).isGreaterThan(0);
    }
}
----

=== Test Resource Configuration

The `PostgresTestResource` configures the Testcontainer:

[source,java]
----
public class PostgresTestResource implements QuarkusTestResourceLifecycleManager {

    private PostgreSQLContainer<?> postgres;

    @Override
    public Map<String, String> start() {
        postgres = new PostgreSQLContainer<>("postgres:16")
            .withDatabaseName("test")
            .withUsername("test")
            .withPassword("test")
            .withInitScript("test-init.sql"); // Enable extensions

        postgres.start();

        return Map.of(
            "quarkus.datasource.jdbc.url", postgres.getJdbcUrl(),
            "quarkus.datasource.username", postgres.getUsername(),
            "quarkus.datasource.password", postgres.getPassword()
        );
    }

    @Override
    public void stop() {
        if (postgres != null) {
            postgres.stop();
        }
    }
}
----

=== Test Initialisation Script

The `test-init.sql` script prepares the test database:

[source,sql]
----
-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;

-- Create test data
CREATE TABLE IF NOT EXISTS test_table (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);

INSERT INTO test_table (name) VALUES
    ('Test 1'),
    ('Test 2'),
    ('Test 3');
----

== End-to-End Tests

End-to-end (E2E) tests validate the complete user experience by automating browser interactions using Microsoft Playwright. These tests verify that all pages load correctly, navigation works, and interactive features behave as expected from a user's perspective.

=== E2E Test Infrastructure

pg-console uses a structured approach to E2E testing with:

* *Playwright* - Browser automation framework supporting Chromium, Firefox, and WebKit
* *Page Object Model* - Encapsulates page interactions in reusable classes
* *Base test class* - Provides common setup, teardown, and helper methods
* *Test tagging* - All E2E tests are tagged with `@Tag("e2e")` for filtering

=== Running E2E Tests

==== All E2E Tests

Run the complete E2E test suite:

[source,bash]
----
gradle21w test --tests '*E2ETest'
----

Alternatively, using the test tag:

[source,bash]
----
gradle21w test --tests '*' --tests '*E2ETest'
----

==== Single E2E Test Class

Run a specific E2E test class:

[source,bash]
----
gradle21w test --tests NavigationE2ETest
gradle21w test --tests ThemeE2ETest
gradle21w test --tests DashboardE2ETest
----

==== Configuration Properties

E2E tests can be configured using system properties:

[cols="1,2,1"]
|===
|Property |Description |Default

|`e2e.baseUrl`
|Base URL for the application under test
|`http://localhost:8080`

|`e2e.browser`
|Browser type: `chromium`, `firefox`, or `webkit`
|`chromium`

|`e2e.headless`
|Run browser in headless mode (no GUI)
|`true`

|`e2e.slowMo`
|Slow down operations by N milliseconds (for debugging)
|`0`

|`e2e.timeout`
|Default timeout in milliseconds
|`30000`

|`e2e.screenshotDir`
|Directory for failure screenshots
|`build/e2e-screenshots`
|===

.Example: Run tests in Firefox with visible browser
[source,bash]
----
gradle21w test --tests '*E2ETest' \
  -De2e.browser=firefox \
  -De2e.headless=false
----

.Example: Run tests with slow motion for debugging
[source,bash]
----
gradle21w test --tests NavigationE2ETest \
  -De2e.headless=false \
  -De2e.slowMo=500
----

=== Test Base Class: PlaywrightTestBase

All E2E tests extend `PlaywrightTestBase`, which provides:

[source,java]
----
@Tag("e2e")
public abstract class PlaywrightTestBase {
    protected static Playwright playwright;
    protected static Browser browser;
    protected BrowserContext context;
    protected Page page;
    protected static final String BASE_URL =
        System.getProperty("e2e.baseUrl", "http://localhost:8080");

    // Lifecycle methods manage Playwright, browser, and page instances
    // Helper methods for common operations
}
----

*Key Features:*

* *Shared Playwright instance* - Created once for all tests in a class
* *Per-test isolation* - Each test gets a fresh browser context and page
* *Automatic cleanup* - Contexts and pages closed after each test
* *Screenshot capture* - Screenshots saved on test failure
* *Helper methods* - Common operations like navigation, waiting, clicking

*Common Helper Methods:*

[source,java]
----
// Navigation
navigateTo("/slow-queries")
navigateToWithInstance("/activity")  // Adds ?instance=default

// Waiting
waitForPageLoad()
waitForElement("table.table")

// Interactions
clickAndWait("a.nav-link")
toggleDarkMode()
setAutoRefresh(30)

// Verification
pageLoadedWithoutErrors()
isVisible("#widget")
getText(".card-title")
getTableRowCount("table.queries")
----

=== Page Object Model

E2E tests use the Page Object Model pattern to encapsulate page-specific interactions.

==== BasePage

The `BasePage` class provides common functionality available on all pages:

[source,java]
----
public class BasePage {
    protected final Page page;
    protected final String baseUrl;

    // Navigation
    public void navigateTo(String path)
    public void navigateToWithInstance(String path)
    public String getCurrentUrl()

    // Common elements
    public String getPageTitle()
    public String getBrowserTitle()
    public boolean isSidebarVisible()
    public void clickNavLink(String linkText)

    // Theme toggle
    public void toggleTheme()
    public boolean isDarkMode()
    public void enableDarkMode()
    public void enableLightMode()

    // Auto-refresh
    public void setAutoRefresh(int seconds)
    public void disableAutoRefresh()

    // Instance selection
    public void selectInstance(String instanceName)
    public String getSelectedInstance()

    // Element helpers
    public boolean isVisible(String selector)
    public String getText(String selector)
    public void click(String selector)
    public int countElements(String selector)

    // Table helpers
    public int getTableRowCount(String tableSelector)
    public void sortTableBy(String headerText)
    public String getTableCell(String tableSelector, int row, int col)
}
----

==== DashboardPage

Encapsulates dashboard-specific interactions:

[source,java]
----
public class DashboardPage extends BasePage {
    public void navigate()

    // Widget visibility checks
    public boolean hasConnectionsWidget()
    public boolean hasActiveQueriesWidget()
    public boolean hasCacheHitWidget()
    public boolean hasDatabaseSizeWidget()
    public boolean hasTopTablesCard()
    public boolean hasTopIndexesCard()

    // Widget values
    public String getConnectionsValue()
    public String getActiveQueriesValue()
    public String getCacheHitValue()
    public String getDatabaseSizeValue()

    // Widget interactions
    public void clickConnectionsWidget()
    public void clickActiveQueriesWidget()

    // Verification
    public boolean allCoreWidgetsVisible()
    public int getTopTablesCount()
    public int getTopIndexesCount()
}
----

==== SlowQueriesPage

Encapsulates slow queries page interactions:

[source,java]
----
public class SlowQueriesPage extends BasePage {
    public void navigate()

    // Table presence
    public boolean hasQueriesTable()
    public boolean hasNoDataMessage()
    public int getQueryCount()

    // Sorting
    public void sortByTotalTime()
    public void sortByMeanTime()
    public void sortByCalls()
    public void sortByRows()

    // Query details
    public void clickFirstQuery()
    public void clickQuery(int index)
    public String getQueryText(int index)
    public String getCalls(int index)
    public String getMeanTime(int index)
    public String getTotalTime(int index)

    // Verification
    public boolean isPageValid()
    public boolean hasSortableHeaders()
}
----

=== Test Categories

E2E tests are organised by functionality:

==== NavigationE2ETest

Verifies that all pages load without errors and navigation works correctly.

[source,java]
----
@DisplayName("Navigation E2E Tests")
class NavigationE2ETest extends PlaywrightTestBase {

    private BasePage basePage;

    @BeforeEach
    void setUpBasePage() {
        basePage = new BasePage(page, BASE_URL);
    }

    @Test
    @DisplayName("Dashboard page loads without errors")
    void dashboardPageLoads() {
        basePage.navigateToWithInstance("/");

        assertTrue(basePage.pageLoadedWithoutErrors(),
            "Dashboard should load without errors");
        assertTrue(basePage.isSidebarVisible(),
            "Sidebar should be visible");
        assertNotNull(basePage.getPageTitle(),
            "Page should have a title");
    }

    @Test
    @DisplayName("Sidebar navigation to slow queries works")
    void sidebarNavigationWorks() {
        basePage.navigateToWithInstance("/");
        basePage.clickNavLink("Slow Queries");

        assertTrue(basePage.getCurrentUrl().contains("/slow-queries"),
            "Should navigate to slow queries");
        assertTrue(basePage.pageLoadedWithoutErrors(),
            "Page should load without errors");
    }
}
----

*Pages Tested:*

* Dashboard (`/`)
* Slow Queries (`/slow-queries`)
* Activity (`/activity`)
* Locks (`/locks`)
* Deadlocks (`/deadlocks`)
* Wait Events (`/wait-events`)
* Tables (`/tables`)
* Databases (`/databases`)
* About (`/about`)
* Index Advisor (`/index-advisor`)
* Query Regressions (`/query-regressions`)
* Table Maintenance (`/table-maintenance`)
* Replication (`/replication`)
* Infrastructure (`/infrastructure`)
* Config Health (`/config-health`)
* Checkpoints (`/checkpoints`)
* WAL Checkpoints (`/wal-checkpoints`)
* Health Check (`/health-check`)
* Security (`/security`)
* Security Roles (`/security/roles`)

==== ThemeE2ETest

Validates dark mode toggle functionality and persistence.

[source,java]
----
@DisplayName("Theme Toggle E2E Tests")
class ThemeE2ETest extends PlaywrightTestBase {

    private BasePage basePage;

    @BeforeEach
    void setUpBasePage() {
        basePage = new BasePage(page, BASE_URL);
    }

    @Test
    @DisplayName("Toggle to dark mode")
    void toggleToDarkMode() {
        basePage.navigateToWithInstance("/");
        basePage.enableLightMode(); // Start from known state

        basePage.toggleTheme();

        assertTrue(basePage.isDarkMode(),
            "Should be in dark mode after toggle");
    }

    @Test
    @DisplayName("Dark mode persists across page navigation")
    void darkModePersistsAcrossNavigation() {
        basePage.navigateToWithInstance("/");
        basePage.enableDarkMode();
        assertTrue(basePage.isDarkMode(), "Should be in dark mode");

        basePage.navigateToWithInstance("/slow-queries");

        assertTrue(basePage.isDarkMode(),
            "Dark mode should persist after navigation");
    }
}
----

*Tests Cover:*

* Theme toggle button visibility
* Toggle to dark mode
* Toggle to light mode
* Dark mode persistence across navigation
* Light mode persistence across navigation
* Theme toggle on multiple pages

==== DashboardE2ETest

Validates dashboard widget display and data.

[source,java]
----
@DisplayName("Dashboard E2E Tests")
class DashboardE2ETest extends PlaywrightTestBase {

    private DashboardPage dashboardPage;

    @BeforeEach
    void setUpDashboardPage() {
        dashboardPage = new DashboardPage(page, BASE_URL);
    }

    @Test
    @DisplayName("Dashboard displays all core widgets")
    void dashboardDisplaysAllWidgets() {
        dashboardPage.navigate();

        assertTrue(dashboardPage.allCoreWidgetsVisible(),
            "All core widgets should be visible");
    }

    @Test
    @DisplayName("Connections widget displays value")
    void connectionsWidgetHasValue() {
        dashboardPage.navigate();

        assertTrue(dashboardPage.hasConnectionsWidget(),
            "Connections widget should be visible");
        String value = dashboardPage.getConnectionsValue();
        assertNotNull(value, "Connections value should not be null");
        assertFalse(value.isEmpty(), "Connections value should not be empty");
    }
}
----

*Widget Tests:*

* Connections widget
* Active queries widget
* Blocked queries widget
* Cache hit ratio widget
* Database size widget
* Top tables card
* Top indexes card
* Sparkline visualisations

=== Writing New E2E Tests

==== Step 1: Create Test Class

Create a new test class extending `PlaywrightTestBase`:

[source,java]
----
package com.bovinemagnet.pgconsole.e2e;

import com.bovinemagnet.pgconsole.e2e.page.BasePage;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("My Feature E2E Tests")
class MyFeatureE2ETest extends PlaywrightTestBase {

    private BasePage basePage;

    @BeforeEach
    void setUpBasePage() {
        basePage = new BasePage(page, BASE_URL);
    }

    @Test
    @DisplayName("Feature should work as expected")
    void featureWorks() {
        // Given: Navigate to the page
        basePage.navigateToWithInstance("/my-feature");

        // When: Perform action
        basePage.click("#myButton");

        // Then: Verify outcome
        assertTrue(basePage.isVisible("#result"),
            "Result should be visible");
        assertEquals("Success", basePage.getText("#result"),
            "Result should show success message");
    }
}
----

==== Step 2: Use Page Objects

For complex pages, create a dedicated Page Object:

[source,java]
----
package com.bovinemagnet.pgconsole.e2e.page;

import com.microsoft.playwright.Page;

public class MyFeaturePage extends BasePage {

    private static final String FEATURE_BUTTON = "#myButton";
    private static final String RESULT_PANEL = "#result";

    public MyFeaturePage(Page page, String baseUrl) {
        super(page, baseUrl);
    }

    public void navigate() {
        navigateToWithInstance("/my-feature");
    }

    public void clickFeatureButton() {
        click(FEATURE_BUTTON);
        waitForElement(RESULT_PANEL);
    }

    public String getResult() {
        return getText(RESULT_PANEL);
    }

    public boolean isFeatureActive() {
        return isVisible(FEATURE_BUTTON);
    }
}
----

Then use it in your test:

[source,java]
----
@DisplayName("My Feature E2E Tests")
class MyFeatureE2ETest extends PlaywrightTestBase {

    private MyFeaturePage featurePage;

    @BeforeEach
    void setUpFeaturePage() {
        featurePage = new MyFeaturePage(page, BASE_URL);
    }

    @Test
    @DisplayName("Feature button triggers expected result")
    void featureButtonWorks() {
        featurePage.navigate();

        featurePage.clickFeatureButton();

        assertEquals("Success", featurePage.getResult());
    }
}
----

==== Step 3: Use @DisplayName Annotations

Use `@DisplayName` for readable test names in reports:

[source,java]
----
@Test
@DisplayName("User can sort queries by total time descending")
void sortQueriesByTotalTime() {
    // Test implementation
}
----

This produces readable test output:

[source,text]
----
SlowQueriesE2ETest
  ✓ User can sort queries by total time descending
  ✓ Query details page displays full SQL text
  ✓ Copy button copies query to clipboard
----

==== Step 4: Follow Best Practices

*Test Independence:*

* Each test should start from a clean state
* Don't rely on execution order
* Use `@BeforeEach` to set up consistent state

*Explicit Waits:*

* Wait for elements before interacting: `waitForElement("#button")`
* Wait for page loads after navigation: `waitForPageLoad()`
* Use timeouts for async operations

*Meaningful Assertions:*

* Include descriptive assertion messages
* Verify positive and negative cases
* Check both presence and content

*Example:*

[source,java]
----
@Test
@DisplayName("Search returns relevant results")
void searchReturnsResults() {
    // Given
    searchPage.navigate();

    // When
    searchPage.enterSearchTerm("SELECT");
    searchPage.clickSearchButton();

    // Then
    assertTrue(searchPage.hasResults(),
        "Search should return at least one result");
    assertTrue(searchPage.getResultCount() > 0,
        "Result count should be greater than zero");
    assertTrue(searchPage.getFirstResultText().contains("SELECT"),
        "First result should contain search term");
}
----

=== CI/CD Integration

E2E tests can be integrated into CI/CD pipelines with special considerations:

==== GitHub Actions Configuration

[source,yaml]
----
name: E2E Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  e2e:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Install Playwright browsers
        run: npx playwright install --with-deps chromium

      - name: Start application
        run: |
          gradle21w quarkusBuild
          java -jar build/quarkus-app/quarkus-run.jar &
          sleep 10  # Wait for application to start

      - name: Run E2E tests
        run: gradle21w test --tests '*E2ETest'
        env:
          E2E_BASE_URL: http://localhost:8080
          E2E_HEADLESS: true

      - name: Upload screenshots on failure
        if: failure()
        uses: actions/upload-artifact@v3
        with:
          name: e2e-screenshots
          path: build/e2e-screenshots/
----

==== Considerations for CI/CD

*Headless Mode:*

* Always run in headless mode in CI: `-De2e.headless=true`
* Use visible browser only for local debugging

*Timeouts:*

* Increase timeouts for slower CI environments
* Use `e2e.timeout` property to adjust: `-De2e.timeout=60000`

*Browser Installation:*

* Install Playwright browsers in CI: `npx playwright install --with-deps`
* Use specific browser for consistency: `-De2e.browser=chromium`

*Screenshot Capture:*

* Screenshots automatically saved to `build/e2e-screenshots/` on failure
* Upload as CI artifacts for debugging failed tests

*Application Startup:*

* Ensure application is fully started before running tests
* Use health check endpoint to verify: `curl --retry 30 http://localhost:8080/q/health`

*Parallel Execution:*

* Playwright tests can run in parallel with isolated browser contexts
* Configure Gradle for parallel test execution if needed

*Test Stability:*

* Use explicit waits instead of hard-coded delays
* Verify element visibility before interaction
* Handle dynamic content with proper waiting strategies

== Code Coverage

pg-console uses JaCoCo to measure test coverage and generate reports.

=== Generating Coverage Reports

Run tests with coverage enabled:

[source,bash]
----
gradle21w test jacocoTestReport
----

This generates:

* HTML report: `build/reports/jacoco/test/html/index.html`
* XML report: `build/reports/jacoco/test/jacocoTestReport.xml`
* CSV report: `build/reports/jacoco/test/jacocoTestReport.csv`

=== Viewing Coverage Reports

Open the HTML report in a browser:

[source,bash]
----
xdg-open build/reports/jacoco/test/html/index.html
----

The report shows:

* Overall coverage percentage
* Coverage by package
* Coverage by class
* Line-by-line coverage in source files

=== Coverage Thresholds

The project enforces minimum coverage thresholds:

* *Line coverage:* 80%
* *Branch coverage:* 70%
* *Complexity coverage:* 75%

Builds fail if coverage falls below these thresholds.

=== Coverage Configuration

JaCoCo is configured in `build.gradle.kts`:

[source,kotlin]
----
jacoco {
    toolVersion = "0.8.11"
}

tasks.jacocoTestReport {
    dependsOn(tasks.test)

    reports {
        xml.required.set(true)
        html.required.set(true)
        csv.required.set(true)
    }
}

tasks.jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = "0.80".toBigDecimal()
            }
        }
        rule {
            element = "BRANCH"
            limit {
                minimum = "0.70".toBigDecimal()
            }
        }
    }
}
----

== CI/CD Pipeline

pg-console uses GitHub Actions for continuous integration and deployment.

=== Workflow Configuration

The `.github/workflows/ci.yml` file defines the pipeline:

[source,yaml]
----
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'

      - name: Run tests
        run: gradle21w test

      - name: Generate coverage report
        run: gradle21w jacocoTestReport

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: build/reports/jacoco/test/jacocoTestReport.xml
----

=== Pipeline Steps

. *Checkout code* from repository
. *Set up Java 21* with Temurin distribution
. *Start PostgreSQL service* for integration tests
. *Run all tests* (unit, integration, E2E)
. *Generate coverage report* with JaCoCo
. *Upload coverage* to Codecov for tracking

=== Quality Gates

The pipeline enforces quality gates:

* All tests must pass
* Coverage thresholds must be met
* Build must succeed without warnings
* Linting rules must pass (if configured)

Pull requests are blocked from merging if any quality gate fails.

== Writing New Tests

=== Unit Test Template

[source,java]
----
@QuarkusTest
class MyServiceTest {

    @Inject
    MyService myService;

    @Test
    void shouldDoSomething() {
        // Given
        // Set up test data

        // When
        // Execute the method under test

        // Then
        // Assert expected outcomes
    }
}
----

=== Integration Test Template

[source,java]
----
@QuarkusTest
@QuarkusTestResource(PostgresTestResource.class)
class MyRepositoryIT {

    @Inject
    MyRepository myRepository;

    @Test
    @Transactional
    void shouldPersistAndRetrieveData() {
        // Given
        // Create test entities

        // When
        // Persist to database
        // Retrieve from database

        // Then
        // Assert data integrity
    }
}
----

=== E2E Test Template

[source,java]
----
package com.bovinemagnet.pgconsole.e2e;

import com.bovinemagnet.pgconsole.e2e.page.BasePage;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

@DisplayName("My Feature E2E Tests")
class MyFeatureE2ETest extends PlaywrightTestBase {

    private BasePage basePage;

    @BeforeEach
    void setUpBasePage() {
        basePage = new BasePage(page, BASE_URL);
    }

    @Test
    @DisplayName("Feature should perform expected workflow")
    void shouldPerformUserWorkflow() {
        // Given: Navigate to the feature page
        basePage.navigateToWithInstance("/my-feature");
        assertTrue(basePage.pageLoadedWithoutErrors(),
            "Page should load without errors");

        // When: Perform user action
        basePage.click("button#action");
        basePage.waitForElement("#result");

        // Then: Verify expected outcome
        assertTrue(basePage.isVisible("#result"),
            "Result should be visible");
        assertTrue(basePage.getText("#result").contains("Expected text"),
            "Result should contain expected text");
    }
}
----

== Best Practices

=== Test Isolation

* Each test should be independent and not rely on other tests
* Use `@Transactional` to rollback database changes after integration tests
* Clean up test data in `@AfterEach` methods if needed
* Avoid shared mutable state between tests

=== Descriptive Assertions

Use AssertJ for readable assertions:

[source,java]
----
// Good: Descriptive and readable
assertThat(result.getConnections())
    .hasSize(10)
    .allMatch(conn -> conn.getState() == State.ACTIVE);

// Bad: Generic and unclear
assertTrue(result.getConnections().size() == 10);
----

=== Test Data Builders

Use builder pattern for complex test data:

[source,java]
----
class SlowQueryBuilder {
    private Long queryId = 123456789L;
    private String queryText = "SELECT 1";
    private Long calls = 1000L;
    private Double totalTime = 5000.0;

    public SlowQueryBuilder withQueryId(Long queryId) {
        this.queryId = queryId;
        return this;
    }

    public SlowQuery build() {
        return new SlowQuery(queryId, queryText, calls, totalTime, ...);
    }
}

// Usage
SlowQuery query = new SlowQueryBuilder()
    .withQueryId(999L)
    .withCalls(5000L)
    .build();
----

=== Parameterised Tests

Use JUnit 5 parameterised tests for multiple test cases:

[source,java]
----
@ParameterizedTest
@CsvSource({
    "total_time, true",
    "calls, true",
    "invalid_column, false"
})
void shouldValidateColumnAllowlist(String column, boolean expected) {
    boolean valid = ALLOWED_COLUMNS.contains(column);
    assertThat(valid).isEqualTo(expected);
}
----

== Next Steps

Now that you understand the testing strategy, explore:

* xref:architecture.adoc[Architecture] - Review the system design
* xref:database-schema.adoc[Database Schema] - Learn about data storage
* xref:admin-guide:configuration.adoc[Configuration] - Configure the application
