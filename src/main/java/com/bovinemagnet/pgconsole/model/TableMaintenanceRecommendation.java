package com.bovinemagnet.pgconsole.model;

import java.time.Instant;
import java.time.temporal.ChronoUnit;

/**
 * Represents a table maintenance recommendation for PostgreSQL database tables.
 *
 * <p>This model encapsulates maintenance recommendations generated by analysing
 * PostgreSQL table statistics from system catalogues such as {@code pg_stat_user_tables}.
 * Recommendations can indicate the need for vacuum operations, statistics updates (analyse),
 * full vacuum for high bloat situations, or index rebuilding operations.
 *
 * <p>Each recommendation includes:
 * <ul>
 *   <li>The specific maintenance operation required ({@link MaintenanceType})</li>
 *   <li>Severity level indicating urgency ({@link Severity})</li>
 *   <li>Table statistics including live/dead tuple counts and bloat estimates</li>
 *   <li>Timestamps of last maintenance operations (manual and automatic)</li>
 *   <li>Computed metrics such as days since last maintenance</li>
 *   <li>Human-readable recommendation text and rationale</li>
 * </ul>
 *
 * <p>The class provides helper methods for formatting data for display in the
 * dashboard UI, including CSS class generation for visual severity indicators
 * and human-readable timestamp displays.
 *
 * @author Paul Snow
 * @version 0.0.0
 * @see com.bovinemagnet.pgconsole.service.PostgresService
 */
public class TableMaintenanceRecommendation {

    /**
     * Enumerates the types of maintenance operations that can be recommended for a table.
     *
     * <p>These maintenance types are derived from PostgreSQL maintenance operations:
     * <ul>
     *   <li>{@link #VACUUM} - Standard vacuum to reclaim dead tuple storage</li>
     *   <li>{@link #ANALYSE} - Update table statistics for query planner</li>
     *   <li>{@link #VACUUM_FULL} - Full vacuum to compact table (locks table)</li>
     *   <li>{@link #REINDEX} - Rebuild indexes to reduce bloat and improve performance</li>
     * </ul>
     */
    public enum MaintenanceType {
        /** Table needs vacuum to reclaim dead tuple storage. */
        VACUUM,
        /** Table needs analyse to update statistics for the query planner. */
        ANALYSE,
        /** Table needs vacuum full due to high bloat (requires exclusive lock). */
        VACUUM_FULL,
        /** Table indexes need rebuilding to reduce bloat. */
        REINDEX
    }

    /**
     * Enumerates severity levels for maintenance recommendations.
     *
     * <p>Severity levels help prioritise maintenance tasks:
     * <ul>
     *   <li>{@link #CRITICAL} - Immediate action needed, performance severely impacted</li>
     *   <li>{@link #HIGH} - Should address soon, noticeable performance degradation</li>
     *   <li>{@link #MEDIUM} - Worth investigating, minor performance impact</li>
     *   <li>{@link #LOW} - Informational, preventative maintenance</li>
     * </ul>
     */
    public enum Severity {
        /** Immediate action needed, performance severely impacted. */
        CRITICAL,
        /** Should address soon, noticeable performance degradation. */
        HIGH,
        /** Worth investigating, minor performance impact. */
        MEDIUM,
        /** Informational, preventative maintenance. */
        LOW
    }

    /** The schema name containing the table. */
    private String schemaName;

    /** The name of the table requiring maintenance. */
    private String tableName;

    /** The type of maintenance operation recommended. */
    private MaintenanceType type;

    /** The severity level of this recommendation. */
    private Severity severity;

    /** Human-readable recommendation text for display. */
    private String recommendation;

    /** Detailed rationale explaining why this maintenance is recommended. */
    private String rationale;

    /** Number of live (active) tuples in the table. */
    private long liveTuples;

    /** Number of dead (obsolete) tuples awaiting vacuum. */
    private long deadTuples;

    /** Ratio of dead tuples to total tuples (0.0 to 1.0). */
    private double deadTupleRatio;

    /** Human-readable table size (e.g., "1.2 GB"). */
    private String tableSize;

    /** Table size in bytes for sorting and calculations. */
    private long tableSizeBytes;

    /** Timestamp of the last manual vacuum operation, or null if never vacuumed. */
    private Instant lastVacuum;

    /** Timestamp of the last autovacuum operation, or null if never auto-vacuumed. */
    private Instant lastAutoVacuum;

    /** Timestamp of the last manual analyse operation, or null if never analysed. */
    private Instant lastAnalyse;

    /** Timestamp of the last auto-analyse operation, or null if never auto-analysed. */
    private Instant lastAutoAnalyse;

    /** Number of days since the last vacuum operation (manual or auto). */
    private long daysSinceVacuum;

    /** Number of days since the last analyse operation (manual or auto). */
    private long daysSinceAnalyse;

    /** Flag indicating the table has never been vacuumed. */
    private boolean neverVacuumed;

    /** Flag indicating the table has never been analysed. */
    private boolean neverAnalysed;

    /** Estimated bloat percentage (0.0 to 100.0+). */
    private double estimatedBloatPercent;

    /** Human-readable estimated bloat size (e.g., "500 MB"). */
    private String estimatedBloatSize;

    /**
     * Constructs a new table maintenance recommendation with default values.
     */
    public TableMaintenanceRecommendation() {
    }

    /**
     * Gets the schema name containing the table.
     *
     * @return the schema name, or null if not set
     */
    public String getSchemaName() {
        return schemaName;
    }

    /**
     * Sets the schema name containing the table.
     *
     * @param schemaName the schema name
     */
    public void setSchemaName(String schemaName) {
        this.schemaName = schemaName;
    }

    /**
     * Gets the name of the table requiring maintenance.
     *
     * @return the table name
     */
    public String getTableName() {
        return tableName;
    }

    /**
     * Sets the name of the table requiring maintenance.
     *
     * @param tableName the table name
     */
    public void setTableName(String tableName) {
        this.tableName = tableName;
    }

    /**
     * Gets the fully qualified table name in the form {@code schema.table}.
     *
     * <p>If the schema name is not set or is empty, returns only the table name.
     * This is useful for display purposes and for generating SQL statements.
     *
     * @return the fully qualified table name, or just the table name if schema is not set
     */
    public String getFullTableName() {
        if (schemaName != null && !schemaName.isEmpty()) {
            return schemaName + "." + tableName;
        }
        return tableName;
    }

    /**
     * Gets the type of maintenance operation recommended.
     *
     * @return the maintenance type
     */
    public MaintenanceType getType() {
        return type;
    }

    /**
     * Sets the type of maintenance operation recommended.
     *
     * @param type the maintenance type
     */
    public void setType(MaintenanceType type) {
        this.type = type;
    }

    /**
     * Gets a human-readable display name for the maintenance type.
     *
     * <p>This method maps maintenance types to user-friendly display names:
     * <ul>
     *   <li>VACUUM → "Vacuum"</li>
     *   <li>ANALYSE → "Analyse"</li>
     *   <li>VACUUM_FULL → "Vacuum Full"</li>
     *   <li>REINDEX → "Reindex"</li>
     * </ul>
     *
     * @return the display name for the maintenance type
     */
    public String getTypeDisplay() {
        return switch (type) {
            case VACUUM -> "Vacuum";
            case ANALYSE -> "Analyse";
            case VACUUM_FULL -> "Vacuum Full";
            case REINDEX -> "Reindex";
        };
    }

    /**
     * Gets Bootstrap CSS classes for styling the maintenance type badge.
     *
     * <p>Returns colour-coded CSS classes appropriate for the maintenance type:
     * <ul>
     *   <li>VACUUM → "bg-warning text-dark" (yellow/orange)</li>
     *   <li>ANALYSE → "bg-info" (light blue)</li>
     *   <li>VACUUM_FULL → "bg-danger" (red, indicating high impact)</li>
     *   <li>REINDEX → "bg-secondary" (grey)</li>
     * </ul>
     *
     * @return Bootstrap CSS class names for the maintenance type
     */
    public String getTypeCssClass() {
        return switch (type) {
            case VACUUM -> "bg-warning text-dark";
            case ANALYSE -> "bg-info";
            case VACUUM_FULL -> "bg-danger";
            case REINDEX -> "bg-secondary";
        };
    }

    /**
     * Gets the severity level of this recommendation.
     *
     * @return the severity level
     */
    public Severity getSeverity() {
        return severity;
    }

    /**
     * Sets the severity level of this recommendation.
     *
     * @param severity the severity level
     */
    public void setSeverity(Severity severity) {
        this.severity = severity;
    }

    /**
     * Gets Bootstrap CSS classes for styling the severity badge.
     *
     * <p>Returns colour-coded CSS classes appropriate for the severity level:
     * <ul>
     *   <li>CRITICAL → "bg-danger" (red)</li>
     *   <li>HIGH → "bg-warning text-dark" (yellow/orange)</li>
     *   <li>MEDIUM → "bg-info" (light blue)</li>
     *   <li>LOW → "bg-secondary" (grey)</li>
     * </ul>
     *
     * @return Bootstrap CSS class names for the severity level
     */
    public String getSeverityCssClass() {
        return switch (severity) {
            case CRITICAL -> "bg-danger";
            case HIGH -> "bg-warning text-dark";
            case MEDIUM -> "bg-info";
            case LOW -> "bg-secondary";
        };
    }

    /**
     * Gets the human-readable recommendation text.
     *
     * @return the recommendation text for display
     */
    public String getRecommendation() {
        return recommendation;
    }

    /**
     * Sets the human-readable recommendation text.
     *
     * @param recommendation the recommendation text
     */
    public void setRecommendation(String recommendation) {
        this.recommendation = recommendation;
    }

    /**
     * Gets the detailed rationale explaining why this maintenance is recommended.
     *
     * @return the rationale text
     */
    public String getRationale() {
        return rationale;
    }

    /**
     * Sets the detailed rationale explaining why this maintenance is recommended.
     *
     * @param rationale the rationale text
     */
    public void setRationale(String rationale) {
        this.rationale = rationale;
    }

    /**
     * Gets the number of live (active) tuples in the table.
     *
     * @return the live tuple count
     */
    public long getLiveTuples() {
        return liveTuples;
    }

    /**
     * Sets the number of live (active) tuples in the table.
     *
     * @param liveTuples the live tuple count
     */
    public void setLiveTuples(long liveTuples) {
        this.liveTuples = liveTuples;
    }

    /**
     * Gets the number of dead (obsolete) tuples awaiting vacuum.
     *
     * @return the dead tuple count
     */
    public long getDeadTuples() {
        return deadTuples;
    }

    /**
     * Sets the number of dead (obsolete) tuples awaiting vacuum.
     *
     * @param deadTuples the dead tuple count
     */
    public void setDeadTuples(long deadTuples) {
        this.deadTuples = deadTuples;
    }

    /**
     * Gets the ratio of dead tuples to total tuples.
     *
     * @return the dead tuple ratio as a decimal (0.0 to 1.0)
     */
    public double getDeadTupleRatio() {
        return deadTupleRatio;
    }

    /**
     * Sets the ratio of dead tuples to total tuples.
     *
     * @param deadTupleRatio the dead tuple ratio as a decimal (0.0 to 1.0)
     */
    public void setDeadTupleRatio(double deadTupleRatio) {
        this.deadTupleRatio = deadTupleRatio;
    }

    /**
     * Gets the dead tuple ratio as a formatted percentage string.
     *
     * <p>Converts the ratio (0.0 to 1.0) to a percentage with one decimal place.
     * For example, a ratio of 0.253 returns "25.3%".
     *
     * @return the formatted percentage string (e.g., "25.3%")
     */
    public String getDeadTupleRatioFormatted() {
        return String.format("%.1f%%", deadTupleRatio * 100);
    }

    /**
     * Gets the human-readable table size.
     *
     * @return the table size as a formatted string (e.g., "1.2 GB")
     */
    public String getTableSize() {
        return tableSize;
    }

    /**
     * Sets the human-readable table size.
     *
     * @param tableSize the table size as a formatted string
     */
    public void setTableSize(String tableSize) {
        this.tableSize = tableSize;
    }

    /**
     * Gets the table size in bytes.
     *
     * <p>This value is useful for sorting and calculations where exact size is needed.
     *
     * @return the table size in bytes
     */
    public long getTableSizeBytes() {
        return tableSizeBytes;
    }

    /**
     * Sets the table size in bytes.
     *
     * @param tableSizeBytes the table size in bytes
     */
    public void setTableSizeBytes(long tableSizeBytes) {
        this.tableSizeBytes = tableSizeBytes;
    }

    /**
     * Gets the timestamp of the last manual vacuum operation.
     *
     * @return the last manual vacuum timestamp, or null if never vacuumed manually
     */
    public Instant getLastVacuum() {
        return lastVacuum;
    }

    /**
     * Sets the timestamp of the last manual vacuum operation.
     *
     * <p>Setting this value automatically updates {@code daysSinceVacuum} and
     * {@code neverVacuumed} based on whether the timestamp is null.
     *
     * @param lastVacuum the last manual vacuum timestamp, or null if never vacuumed manually
     */
    public void setLastVacuum(Instant lastVacuum) {
        this.lastVacuum = lastVacuum;
        if (lastVacuum != null) {
            this.daysSinceVacuum = ChronoUnit.DAYS.between(lastVacuum, Instant.now());
            this.neverVacuumed = false;
        } else {
            this.neverVacuumed = true;
        }
    }

    /**
     * Gets the timestamp of the last autovacuum operation.
     *
     * @return the last autovacuum timestamp, or null if never auto-vacuumed
     */
    public Instant getLastAutoVacuum() {
        return lastAutoVacuum;
    }

    /**
     * Sets the timestamp of the last autovacuum operation.
     *
     * @param lastAutoVacuum the last autovacuum timestamp
     */
    public void setLastAutoVacuum(Instant lastAutoVacuum) {
        this.lastAutoVacuum = lastAutoVacuum;
    }

    /**
     * Gets the timestamp of the last manual analyse operation.
     *
     * @return the last manual analyse timestamp, or null if never analysed manually
     */
    public Instant getLastAnalyse() {
        return lastAnalyse;
    }

    /**
     * Sets the timestamp of the last manual analyse operation.
     *
     * <p>Setting this value automatically updates {@code daysSinceAnalyse} and
     * {@code neverAnalysed} based on whether the timestamp is null.
     *
     * @param lastAnalyse the last manual analyse timestamp, or null if never analysed manually
     */
    public void setLastAnalyse(Instant lastAnalyse) {
        this.lastAnalyse = lastAnalyse;
        if (lastAnalyse != null) {
            this.daysSinceAnalyse = ChronoUnit.DAYS.between(lastAnalyse, Instant.now());
            this.neverAnalysed = false;
        } else {
            this.neverAnalysed = true;
        }
    }

    /**
     * Gets the timestamp of the last auto-analyse operation.
     *
     * @return the last auto-analyse timestamp, or null if never auto-analysed
     */
    public Instant getLastAutoAnalyse() {
        return lastAutoAnalyse;
    }

    /**
     * Sets the timestamp of the last auto-analyse operation.
     *
     * @param lastAutoAnalyse the last auto-analyse timestamp
     */
    public void setLastAutoAnalyse(Instant lastAutoAnalyse) {
        this.lastAutoAnalyse = lastAutoAnalyse;
    }

    /**
     * Gets the number of days since the last vacuum operation.
     *
     * <p>This value is automatically calculated when {@link #setLastVacuum(Instant)}
     * is called. It represents days elapsed from the last manual vacuum to now.
     *
     * @return the number of days since last vacuum
     */
    public long getDaysSinceVacuum() {
        return daysSinceVacuum;
    }

    /**
     * Gets the number of days since the last analyse operation.
     *
     * <p>This value is automatically calculated when {@link #setLastAnalyse(Instant)}
     * is called. It represents days elapsed from the last manual analyse to now.
     *
     * @return the number of days since last analyse
     */
    public long getDaysSinceAnalyse() {
        return daysSinceAnalyse;
    }

    /**
     * Checks whether the table has never been vacuumed.
     *
     * <p>This flag is automatically set when {@link #setLastVacuum(Instant)} is called
     * with a null value.
     *
     * @return true if the table has never been vacuumed, false otherwise
     */
    public boolean isNeverVacuumed() {
        return neverVacuumed;
    }

    /**
     * Checks whether the table has never been analysed.
     *
     * <p>This flag is automatically set when {@link #setLastAnalyse(Instant)} is called
     * with a null value.
     *
     * @return true if the table has never been analysed, false otherwise
     */
    public boolean isNeverAnalysed() {
        return neverAnalysed;
    }

    /**
     * Gets a human-readable display string for the last vacuum timestamp.
     *
     * <p>Formats the timestamp as:
     * <ul>
     *   <li>"Never" if the table has never been vacuumed</li>
     *   <li>"Today" if vacuumed today</li>
     *   <li>"Yesterday" if vacuumed yesterday</li>
     *   <li>"N days ago" for older vacuum operations</li>
     * </ul>
     *
     * @return the formatted display string
     */
    public String getLastVacuumDisplay() {
        if (neverVacuumed) {
            return "Never";
        }
        if (daysSinceVacuum == 0) {
            return "Today";
        } else if (daysSinceVacuum == 1) {
            return "Yesterday";
        } else {
            return daysSinceVacuum + " days ago";
        }
    }

    /**
     * Gets a human-readable display string for the last analyse timestamp.
     *
     * <p>Formats the timestamp as:
     * <ul>
     *   <li>"Never" if the table has never been analysed</li>
     *   <li>"Today" if analysed today</li>
     *   <li>"Yesterday" if analysed yesterday</li>
     *   <li>"N days ago" for older analyse operations</li>
     * </ul>
     *
     * @return the formatted display string
     */
    public String getLastAnalyseDisplay() {
        if (neverAnalysed) {
            return "Never";
        }
        if (daysSinceAnalyse == 0) {
            return "Today";
        } else if (daysSinceAnalyse == 1) {
            return "Yesterday";
        } else {
            return daysSinceAnalyse + " days ago";
        }
    }

    /**
     * Gets the estimated bloat percentage.
     *
     * @return the estimated bloat percentage (0.0 to 100.0+)
     */
    public double getEstimatedBloatPercent() {
        return estimatedBloatPercent;
    }

    /**
     * Sets the estimated bloat percentage.
     *
     * @param estimatedBloatPercent the estimated bloat percentage
     */
    public void setEstimatedBloatPercent(double estimatedBloatPercent) {
        this.estimatedBloatPercent = estimatedBloatPercent;
    }

    /**
     * Gets the estimated bloat percentage as a formatted string.
     *
     * <p>Formats the percentage with one decimal place.
     * For example, 25.3 returns "25.3%".
     *
     * @return the formatted percentage string (e.g., "25.3%")
     */
    public String getEstimatedBloatPercentFormatted() {
        return String.format("%.1f%%", estimatedBloatPercent);
    }

    /**
     * Gets the human-readable estimated bloat size.
     *
     * @return the estimated bloat size as a formatted string (e.g., "500 MB")
     */
    public String getEstimatedBloatSize() {
        return estimatedBloatSize;
    }

    /**
     * Sets the human-readable estimated bloat size.
     *
     * @param estimatedBloatSize the estimated bloat size as a formatted string
     */
    public void setEstimatedBloatSize(String estimatedBloatSize) {
        this.estimatedBloatSize = estimatedBloatSize;
    }

    /**
     * Gets the most recent vacuum timestamp from either manual or automatic vacuum.
     *
     * <p>This method compares {@link #lastVacuum} and {@link #lastAutoVacuum} and
     * returns whichever occurred most recently. This is useful for determining when
     * the table was last vacuumed regardless of whether it was manual or automatic.
     *
     * @return the most recent vacuum timestamp, or null if the table has never been vacuumed
     */
    public Instant getEffectiveLastVacuum() {
        if (lastVacuum == null) return lastAutoVacuum;
        if (lastAutoVacuum == null) return lastVacuum;
        return lastVacuum.isAfter(lastAutoVacuum) ? lastVacuum : lastAutoVacuum;
    }

    /**
     * Gets the most recent analyse timestamp from either manual or automatic analyse.
     *
     * <p>This method compares {@link #lastAnalyse} and {@link #lastAutoAnalyse} and
     * returns whichever occurred most recently. This is useful for determining when
     * the table statistics were last updated regardless of whether it was manual or automatic.
     *
     * @return the most recent analyse timestamp, or null if the table has never been analysed
     */
    public Instant getEffectiveLastAnalyse() {
        if (lastAnalyse == null) return lastAutoAnalyse;
        if (lastAutoAnalyse == null) return lastAnalyse;
        return lastAnalyse.isAfter(lastAutoAnalyse) ? lastAnalyse : lastAutoAnalyse;
    }
}
