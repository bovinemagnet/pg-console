package com.bovinemagnet.pgconsole.model;

import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Generated DDL migration script from schema comparison.
 * <p>
 * This class represents a complete database migration script generated by comparing
 * two PostgreSQL schemas (source and destination). It contains ordered DDL statements
 * that can be executed to bring the destination schema into alignment with the source.
 * <p>
 * The script supports multiple execution modes via {@link WrapOption}, including
 * single transaction, individual statements, or savepoint-based execution. It also
 * provides filtering capabilities to include or exclude DROP statements, and can
 * generate separate CREATE, ALTER, and DROP statement lists.
 * <p>
 * Each migration script tracks metadata including generation timestamp, source and
 * destination instances, and schema names. Statements are ordered according to
 * dependency requirements to ensure proper execution order.
 *
 * <pre>{@code
 * MigrationScript script = new MigrationScript();
 * script.setSourceInstance("prod");
 * script.setDestinationInstance("dev");
 * script.setSourceSchema("public");
 * script.setDestinationSchema("public");
 * script.setWrapOption(WrapOption.SINGLE_TRANSACTION);
 *
 * MigrationStatement stmt = MigrationStatement.builder()
 *     .order(1)
 *     .ddl("CREATE TABLE users (id SERIAL PRIMARY KEY)")
 *     .objectType(ObjectDifference.ObjectType.TABLE)
 *     .objectName("users")
 *     .severity(ObjectDifference.Severity.SAFE)
 *     .build();
 * script.addStatement(stmt);
 *
 * String fullScript = script.getFullScript();
 * }</pre>
 *
 * @author Paul Snow
 * @version 0.0.0
 * @see MigrationStatement
 * @see ObjectDifference
 */
public class MigrationScript {

    /**
     * Transaction wrapping options for migration scripts.
     * <p>
     * Defines how DDL statements are wrapped in transaction control statements.
     * Each option provides different trade-offs between atomicity and error recovery.
     */
    public enum WrapOption {
        /**
         * Wraps all statements in a single BEGIN/COMMIT block.
         * All statements succeed or fail together atomically.
         */
        SINGLE_TRANSACTION("Single Transaction",
                "Wrap all statements in a single BEGIN/COMMIT block"),

        /**
         * Executes each statement independently without transaction wrapping.
         * Allows partial migration even if some statements fail.
         */
        INDIVIDUAL_STATEMENTS("Individual Statements",
                "Execute each statement independently"),

        /**
         * Uses savepoints before each statement to allow partial rollback on errors.
         * Provides a middle ground between full atomicity and independence.
         */
        SAVEPOINT_PER_OBJECT("Savepoints",
                "Use savepoints to allow partial rollback on errors");

        private final String displayName;
        private final String description;

        /**
         * Constructs a WrapOption with display name and description.
         *
         * @param displayName human-readable name for UI display
         * @param description detailed explanation of the option's behaviour
         */
        WrapOption(String displayName, String description) {
            this.displayName = displayName;
            this.description = description;
        }

        /**
         * Gets the human-readable display name.
         *
         * @return display name for UI presentation
         */
        public String getDisplayName() {
            return displayName;
        }

        /**
         * Gets the detailed description of this option's behaviour.
         *
         * @return description explaining how this option works
         */
        public String getDescription() {
            return description;
        }
    }

    /** List of DDL statements comprising this migration. */
    private List<MigrationStatement> statements = new ArrayList<>();

    /** Transaction wrapping mode for script execution. */
    private WrapOption wrapOption = WrapOption.SINGLE_TRANSACTION;

    /** Whether to include DROP statements in the generated script. */
    private boolean includeDropStatements;

    /** Timestamp when this migration script was generated. */
    private Instant generatedAt;

    /** Username or identifier of the person who generated this script. */
    private String generatedBy;

    /** Source database instance name. */
    private String sourceInstance;

    /** Destination database instance name. */
    private String destinationInstance;

    /** Source schema name. */
    private String sourceSchema;

    /** Destination schema name. */
    private String destinationSchema;

    /**
     * Constructs a new MigrationScript with generation timestamp set to now.
     */
    public MigrationScript() {
        this.generatedAt = Instant.now();
    }

    /**
     * Gets the full migration script as a single string.
     * <p>
     * Generates a complete SQL script including header comments with metadata,
     * transaction control statements based on {@link #wrapOption}, and all DDL
     * statements in dependency order. DROP statements are filtered based on
     * {@link #includeDropStatements}.
     *
     * @return complete SQL migration script ready for execution
     */
    public String getFullScript() {
        StringBuilder script = new StringBuilder();

        // Header comment
        script.append("-- Migration Script\n");
        script.append("-- Generated: ").append(getGeneratedAtFormatted()).append("\n");
        script.append("-- Source: ").append(sourceInstance).append(".").append(sourceSchema).append("\n");
        script.append("-- Destination: ").append(destinationInstance).append(".").append(destinationSchema).append("\n");
        script.append("-- Statements: ").append(statements.size()).append("\n");
        script.append("\n");

        List<MigrationStatement> orderedStatements = getOrderedStatements();

        switch (wrapOption) {
            case SINGLE_TRANSACTION -> {
                script.append("BEGIN;\n\n");
                for (MigrationStatement stmt : orderedStatements) {
                    if (!includeDropStatements && stmt.isDropStatement()) {
                        continue;
                    }
                    script.append(formatStatement(stmt));
                }
                script.append("COMMIT;\n");
            }
            case INDIVIDUAL_STATEMENTS -> {
                for (MigrationStatement stmt : orderedStatements) {
                    if (!includeDropStatements && stmt.isDropStatement()) {
                        continue;
                    }
                    script.append(formatStatement(stmt));
                }
            }
            case SAVEPOINT_PER_OBJECT -> {
                script.append("BEGIN;\n\n");
                int savepoint = 0;
                for (MigrationStatement stmt : orderedStatements) {
                    if (!includeDropStatements && stmt.isDropStatement()) {
                        continue;
                    }
                    script.append("SAVEPOINT sp_").append(savepoint++).append(";\n");
                    script.append(formatStatement(stmt));
                }
                script.append("COMMIT;\n");
            }
        }

        return script.toString();
    }

    /**
     * Formats a single migration statement with comments and DDL.
     * <p>
     * Adds warning messages (if present), object type and name comments,
     * the DDL statement itself, and ensures proper semicolon termination.
     *
     * @param stmt the statement to format
     * @return formatted SQL statement with comments
     */
    private String formatStatement(MigrationStatement stmt) {
        StringBuilder sb = new StringBuilder();
        if (stmt.warningMessage != null) {
            sb.append("-- WARNING: ").append(stmt.warningMessage).append("\n");
        }
        sb.append("-- ").append(stmt.objectType.getDisplayName())
                .append(": ").append(stmt.objectName).append("\n");
        sb.append(stmt.ddl);
        if (!stmt.ddl.endsWith(";")) {
            sb.append(";");
        }
        sb.append("\n\n");
        return sb.toString();
    }

    /**
     * Gets statements ordered by dependency.
     * <p>
     * Returns all statements sorted by their order field, which ensures
     * dependencies are executed before dependent objects.
     *
     * @return ordered list of statements
     */
    public List<MigrationStatement> getOrderedStatements() {
        return statements.stream()
                .sorted(Comparator.comparingInt(s -> s.order))
                .collect(Collectors.toList());
    }

    /**
     * Gets only CREATE statements.
     * <p>
     * Filters and returns only statements beginning with CREATE, ordered by
     * dependency, as a semicolon-terminated SQL script.
     *
     * @return CREATE statements only, or empty string if none
     */
    public String getCreateStatementsOnly() {
        return statements.stream()
                .filter(s -> s.ddl.trim().toUpperCase().startsWith("CREATE"))
                .sorted(Comparator.comparingInt(s -> s.order))
                .map(s -> s.ddl + (s.ddl.endsWith(";") ? "" : ";"))
                .collect(Collectors.joining("\n\n"));
    }

    /**
     * Gets only ALTER statements.
     * <p>
     * Filters and returns only statements beginning with ALTER, ordered by
     * dependency, as a semicolon-terminated SQL script.
     *
     * @return ALTER statements only, or empty string if none
     */
    public String getAlterStatementsOnly() {
        return statements.stream()
                .filter(s -> s.ddl.trim().toUpperCase().startsWith("ALTER"))
                .sorted(Comparator.comparingInt(s -> s.order))
                .map(s -> s.ddl + (s.ddl.endsWith(";") ? "" : ";"))
                .collect(Collectors.joining("\n\n"));
    }

    /**
     * Gets only DROP statements.
     * <p>
     * Filters and returns only statements beginning with DROP, ordered by
     * dependency, as a semicolon-terminated SQL script.
     *
     * @return DROP statements only, or empty string if none
     */
    public String getDropStatementsOnly() {
        return statements.stream()
                .filter(MigrationStatement::isDropStatement)
                .sorted(Comparator.comparingInt(s -> s.order))
                .map(s -> s.ddl + (s.ddl.endsWith(";") ? "" : ";"))
                .collect(Collectors.joining("\n\n"));
    }

    /**
     * Gets formatted generation timestamp.
     * <p>
     * Returns the timestamp in yyyy-MM-dd HH:mm:ss format using the system
     * default timezone.
     *
     * @return formatted date/time string
     */
    public String getGeneratedAtFormatted() {
        return DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
                .withZone(ZoneId.systemDefault())
                .format(generatedAt);
    }

    /**
     * Gets total statement count.
     *
     * @return total number of statements in this migration
     */
    public int getStatementCount() {
        return statements.size();
    }

    /**
     * Gets count of breaking (DROP) statements.
     * <p>
     * Counts statements with severity level BREAKING, which typically
     * includes DROP and destructive ALTER operations.
     *
     * @return number of breaking statements
     */
    public long getBreakingStatementCount() {
        return statements.stream()
                .filter(s -> s.severity == ObjectDifference.Severity.BREAKING)
                .count();
    }

    /**
     * Adds a migration statement to this script.
     * <p>
     * Statements should be added in the order they should execute, though
     * the order field will be used for final sorting.
     *
     * @param statement the statement to add
     */
    public void addStatement(MigrationStatement statement) {
        statements.add(statement);
    }

    /**
     * Single DDL statement in the migration.
     * <p>
     * Represents an individual database schema change operation including the DDL
     * statement, metadata about the affected object, execution order, severity level,
     * dependencies, and optional rollback information.
     * <p>
     * Statements can be created using the {@link Builder} pattern for cleaner construction.
     *
     * @see Builder
     */
    public static class MigrationStatement {
        /** Execution order position (lower numbers execute first). */
        private int order;

        /** The actual DDL SQL statement. */
        private String ddl;

        /** Type of database object being modified. */
        private ObjectDifference.ObjectType objectType;

        /** Name of the database object being modified. */
        private String objectName;

        /** Severity level of this change (SAFE, COMPATIBLE, BREAKING). */
        private ObjectDifference.Severity severity;

        /** List of object names this statement depends on. */
        private List<String> dependencies = new ArrayList<>();

        /** Optional warning message about this statement. */
        private String warningMessage;

        /** Whether this statement can be automatically rolled back. */
        private boolean reversible;

        /** DDL to rollback this statement if reversible. */
        private String rollbackDdl;

        /**
         * Constructs an empty MigrationStatement.
         */
        public MigrationStatement() {
        }

        /**
         * Constructs a MigrationStatement with core properties.
         *
         * @param order execution order position
         * @param ddl the DDL SQL statement
         * @param objectType type of object being modified
         * @param objectName name of the object
         * @param severity severity level of the change
         */
        public MigrationStatement(int order, String ddl, ObjectDifference.ObjectType objectType,
                                   String objectName, ObjectDifference.Severity severity) {
            this.order = order;
            this.ddl = ddl;
            this.objectType = objectType;
            this.objectName = objectName;
            this.severity = severity;
        }

        /**
         * Checks if this is a DROP statement.
         *
         * @return true if DDL begins with DROP
         */
        public boolean isDropStatement() {
            return ddl != null && ddl.trim().toUpperCase().startsWith("DROP");
        }

        /**
         * Checks if this is a CREATE statement.
         *
         * @return true if DDL begins with CREATE
         */
        public boolean isCreateStatement() {
            return ddl != null && ddl.trim().toUpperCase().startsWith("CREATE");
        }

        /**
         * Checks if this is an ALTER statement.
         *
         * @return true if DDL begins with ALTER
         */
        public boolean isAlterStatement() {
            return ddl != null && ddl.trim().toUpperCase().startsWith("ALTER");
        }

        /**
         * Creates a new Builder for constructing MigrationStatements.
         *
         * @return new Builder instance
         */
        public static Builder builder() {
            return new Builder();
        }

        /**
         * Builder for constructing MigrationStatement instances.
         * <p>
         * Provides a fluent API for setting statement properties.
         *
         * <pre>{@code
         * MigrationStatement stmt = MigrationStatement.builder()
         *     .order(1)
         *     .ddl("CREATE TABLE users (id SERIAL)")
         *     .objectType(ObjectDifference.ObjectType.TABLE)
         *     .objectName("users")
         *     .severity(ObjectDifference.Severity.SAFE)
         *     .dependency("public.roles")
         *     .warningMessage("This will create a new table")
         *     .reversible(true)
         *     .rollbackDdl("DROP TABLE users")
         *     .build();
         * }</pre>
         */
        public static class Builder {
            private final MigrationStatement stmt = new MigrationStatement();

            /**
             * Sets the execution order.
             *
             * @param order execution order (lower numbers first)
             * @return this builder
             */
            public Builder order(int order) { stmt.order = order; return this; }

            /**
             * Sets the DDL statement.
             *
             * @param ddl the SQL DDL statement
             * @return this builder
             */
            public Builder ddl(String ddl) { stmt.ddl = ddl; return this; }

            /**
             * Sets the object type.
             *
             * @param objectType type of database object
             * @return this builder
             */
            public Builder objectType(ObjectDifference.ObjectType objectType) { stmt.objectType = objectType; return this; }

            /**
             * Sets the object name.
             *
             * @param objectName name of the database object
             * @return this builder
             */
            public Builder objectName(String objectName) { stmt.objectName = objectName; return this; }

            /**
             * Sets the severity level.
             *
             * @param severity severity of this change
             * @return this builder
             */
            public Builder severity(ObjectDifference.Severity severity) { stmt.severity = severity; return this; }

            /**
             * Adds a dependency.
             *
             * @param dep name of dependent object
             * @return this builder
             */
            public Builder dependency(String dep) { stmt.dependencies.add(dep); return this; }

            /**
             * Sets the warning message.
             *
             * @param msg warning message to display
             * @return this builder
             */
            public Builder warningMessage(String msg) { stmt.warningMessage = msg; return this; }

            /**
             * Sets whether this statement is reversible.
             *
             * @param rev true if reversible
             * @return this builder
             */
            public Builder reversible(boolean rev) { stmt.reversible = rev; return this; }

            /**
             * Sets the rollback DDL.
             *
             * @param ddl DDL statement to rollback this change
             * @return this builder
             */
            public Builder rollbackDdl(String ddl) { stmt.rollbackDdl = ddl; return this; }

            /**
             * Builds the MigrationStatement.
             *
             * @return the constructed statement
             */
            public MigrationStatement build() { return stmt; }
        }

        // Getters and Setters

        /**
         * Gets the execution order.
         *
         * @return execution order position
         */
        public int getOrder() { return order; }

        /**
         * Sets the execution order.
         *
         * @param order execution order position
         */
        public void setOrder(int order) { this.order = order; }

        /**
         * Gets the DDL statement.
         *
         * @return the SQL DDL statement
         */
        public String getDdl() { return ddl; }

        /**
         * Sets the DDL statement.
         *
         * @param ddl the SQL DDL statement
         */
        public void setDdl(String ddl) { this.ddl = ddl; }

        /**
         * Gets the object type.
         *
         * @return type of database object being modified
         */
        public ObjectDifference.ObjectType getObjectType() { return objectType; }

        /**
         * Sets the object type.
         *
         * @param objectType type of database object
         */
        public void setObjectType(ObjectDifference.ObjectType objectType) { this.objectType = objectType; }

        /**
         * Gets the object name.
         *
         * @return name of the database object
         */
        public String getObjectName() { return objectName; }

        /**
         * Sets the object name.
         *
         * @param objectName name of the database object
         */
        public void setObjectName(String objectName) { this.objectName = objectName; }

        /**
         * Gets the severity level.
         *
         * @return severity of this change
         */
        public ObjectDifference.Severity getSeverity() { return severity; }

        /**
         * Sets the severity level.
         *
         * @param severity severity of this change
         */
        public void setSeverity(ObjectDifference.Severity severity) { this.severity = severity; }

        /**
         * Gets the list of dependencies.
         *
         * @return list of object names this statement depends on
         */
        public List<String> getDependencies() { return dependencies; }

        /**
         * Sets the list of dependencies.
         *
         * @param dependencies list of object names this statement depends on
         */
        public void setDependencies(List<String> dependencies) { this.dependencies = dependencies; }

        /**
         * Gets the warning message.
         *
         * @return warning message, or null if none
         */
        public String getWarningMessage() { return warningMessage; }

        /**
         * Sets the warning message.
         *
         * @param warningMessage warning message about this statement
         */
        public void setWarningMessage(String warningMessage) { this.warningMessage = warningMessage; }

        /**
         * Checks if this statement is reversible.
         *
         * @return true if this statement can be rolled back
         */
        public boolean isReversible() { return reversible; }

        /**
         * Sets whether this statement is reversible.
         *
         * @param reversible true if this statement can be rolled back
         */
        public void setReversible(boolean reversible) { this.reversible = reversible; }

        /**
         * Gets the rollback DDL.
         *
         * @return DDL to rollback this change, or null if not reversible
         */
        public String getRollbackDdl() { return rollbackDdl; }

        /**
         * Sets the rollback DDL.
         *
         * @param rollbackDdl DDL statement to rollback this change
         */
        public void setRollbackDdl(String rollbackDdl) { this.rollbackDdl = rollbackDdl; }
    }

    // Getters and Setters

    /**
     * Gets the list of statements.
     *
     * @return mutable list of migration statements
     */
    public List<MigrationStatement> getStatements() {
        return statements;
    }

    /**
     * Sets the list of statements.
     *
     * @param statements list of migration statements
     */
    public void setStatements(List<MigrationStatement> statements) {
        this.statements = statements;
    }

    /**
     * Gets the transaction wrapping option.
     *
     * @return the wrap option for script execution
     */
    public WrapOption getWrapOption() {
        return wrapOption;
    }

    /**
     * Sets the transaction wrapping option.
     *
     * @param wrapOption the wrap option for script execution
     */
    public void setWrapOption(WrapOption wrapOption) {
        this.wrapOption = wrapOption;
    }

    /**
     * Checks if DROP statements should be included.
     *
     * @return true if DROP statements will be included in generated script
     */
    public boolean isIncludeDropStatements() {
        return includeDropStatements;
    }

    /**
     * Sets whether to include DROP statements.
     *
     * @param includeDropStatements true to include DROP statements
     */
    public void setIncludeDropStatements(boolean includeDropStatements) {
        this.includeDropStatements = includeDropStatements;
    }

    /**
     * Gets the generation timestamp.
     *
     * @return instant when this script was generated
     */
    public Instant getGeneratedAt() {
        return generatedAt;
    }

    /**
     * Sets the generation timestamp.
     *
     * @param generatedAt instant when this script was generated
     */
    public void setGeneratedAt(Instant generatedAt) {
        this.generatedAt = generatedAt;
    }

    /**
     * Gets the generator identifier.
     *
     * @return username or identifier of who generated this script
     */
    public String getGeneratedBy() {
        return generatedBy;
    }

    /**
     * Sets the generator identifier.
     *
     * @param generatedBy username or identifier of who generated this script
     */
    public void setGeneratedBy(String generatedBy) {
        this.generatedBy = generatedBy;
    }

    /**
     * Gets the source instance name.
     *
     * @return source database instance name
     */
    public String getSourceInstance() {
        return sourceInstance;
    }

    /**
     * Sets the source instance name.
     *
     * @param sourceInstance source database instance name
     */
    public void setSourceInstance(String sourceInstance) {
        this.sourceInstance = sourceInstance;
    }

    /**
     * Gets the destination instance name.
     *
     * @return destination database instance name
     */
    public String getDestinationInstance() {
        return destinationInstance;
    }

    /**
     * Sets the destination instance name.
     *
     * @param destinationInstance destination database instance name
     */
    public void setDestinationInstance(String destinationInstance) {
        this.destinationInstance = destinationInstance;
    }

    /**
     * Gets the source schema name.
     *
     * @return source schema name
     */
    public String getSourceSchema() {
        return sourceSchema;
    }

    /**
     * Sets the source schema name.
     *
     * @param sourceSchema source schema name
     */
    public void setSourceSchema(String sourceSchema) {
        this.sourceSchema = sourceSchema;
    }

    /**
     * Gets the destination schema name.
     *
     * @return destination schema name
     */
    public String getDestinationSchema() {
        return destinationSchema;
    }

    /**
     * Sets the destination schema name.
     *
     * @param destinationSchema destination schema name
     */
    public void setDestinationSchema(String destinationSchema) {
        this.destinationSchema = destinationSchema;
    }
}
