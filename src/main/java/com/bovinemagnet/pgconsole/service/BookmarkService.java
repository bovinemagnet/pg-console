package com.bovinemagnet.pgconsole.service;

import com.bovinemagnet.pgconsole.model.QueryBookmark;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import org.jboss.logging.Logger;

import javax.sql.DataSource;
import java.sql.Array;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Service for managing query bookmarks.
 *
 * @author Paul Snow
 * @version 0.0.0
 */
@ApplicationScoped
public class BookmarkService {

    private static final Logger LOG = Logger.getLogger(BookmarkService.class);

    @Inject
    DataSource dataSource;

    /**
     * Creates a new query bookmark in the database.
     * <p>
     * Inserts a bookmark record with the current timestamp for both created_at and updated_at.
     * The bookmark ID is generated by the database and populated into the returned object.
     * Tags are stored as a PostgreSQL array.
     *
     * @param bookmark the bookmark to create; ID will be populated after creation
     * @return the created bookmark with ID and timestamps populated
     */
    public QueryBookmark create(QueryBookmark bookmark) {
        String sql = """
            INSERT INTO pgconsole.query_bookmark
            (created_at, updated_at, instance_id, query_id, query_text, title, notes, tags, created_by, priority, status)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            RETURNING id
            """;

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            Timestamp now = Timestamp.from(Instant.now());
            stmt.setTimestamp(1, now);
            stmt.setTimestamp(2, now);
            stmt.setString(3, bookmark.getInstanceId());
            stmt.setString(4, bookmark.getQueryId());
            stmt.setString(5, bookmark.getQueryText());
            stmt.setString(6, bookmark.getTitle());
            stmt.setString(7, bookmark.getNotes());

            if (bookmark.getTags() != null && !bookmark.getTags().isEmpty()) {
                Array tagsArray = conn.createArrayOf("TEXT", bookmark.getTags().toArray());
                stmt.setArray(8, tagsArray);
            } else {
                stmt.setArray(8, null);
            }

            stmt.setString(9, bookmark.getCreatedBy());
            stmt.setString(10, bookmark.getPriority().name().toLowerCase());
            stmt.setString(11, bookmark.getStatus().name().toLowerCase());

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    bookmark.setId(rs.getLong("id"));
                    bookmark.setCreatedAt(now.toInstant());
                    bookmark.setUpdatedAt(now.toInstant());
                }
            }

            LOG.infof("Created bookmark %d for query %s", bookmark.getId(), bookmark.getQueryId());

        } catch (SQLException e) {
            LOG.errorf("Failed to create bookmark: %s", e.getMessage());
        }

        return bookmark;
    }

    /**
     * Updates an existing query bookmark in the database.
     * <p>
     * Updates the title, notes, tags, priority, and status fields.
     * The updated_at timestamp is automatically set to the current time.
     * The ID field is used to identify which bookmark to update.
     *
     * @param bookmark the bookmark with updated values; must have a valid ID
     * @return the updated bookmark with refreshed updated_at timestamp
     */
    public QueryBookmark update(QueryBookmark bookmark) {
        String sql = """
            UPDATE pgconsole.query_bookmark
            SET updated_at = ?, title = ?, notes = ?, tags = ?, priority = ?, status = ?
            WHERE id = ?
            """;

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            Timestamp now = Timestamp.from(Instant.now());
            stmt.setTimestamp(1, now);
            stmt.setString(2, bookmark.getTitle());
            stmt.setString(3, bookmark.getNotes());

            if (bookmark.getTags() != null && !bookmark.getTags().isEmpty()) {
                Array tagsArray = conn.createArrayOf("TEXT", bookmark.getTags().toArray());
                stmt.setArray(4, tagsArray);
            } else {
                stmt.setArray(4, null);
            }

            stmt.setString(5, bookmark.getPriority().name().toLowerCase());
            stmt.setString(6, bookmark.getStatus().name().toLowerCase());
            stmt.setLong(7, bookmark.getId());

            stmt.executeUpdate();
            bookmark.setUpdatedAt(now.toInstant());

            LOG.infof("Updated bookmark %d", bookmark.getId());

        } catch (SQLException e) {
            LOG.errorf("Failed to update bookmark: %s", e.getMessage());
        }

        return bookmark;
    }

    /**
     * Deletes a query bookmark from the database.
     *
     * @param id the ID of the bookmark to delete
     * @return true if the bookmark was deleted successfully, false if no bookmark was found
     */
    public boolean delete(long id) {
        String sql = "DELETE FROM pgconsole.query_bookmark WHERE id = ?";

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);
            int rows = stmt.executeUpdate();

            if (rows > 0) {
                LOG.infof("Deleted bookmark %d", id);
                return true;
            }

        } catch (SQLException e) {
            LOG.errorf("Failed to delete bookmark: %s", e.getMessage());
        }

        return false;
    }

    /**
     * Retrieves a query bookmark by its unique ID.
     *
     * @param id the bookmark ID
     * @return the bookmark, or null if not found
     */
    public QueryBookmark getById(long id) {
        String sql = """
            SELECT id, created_at, updated_at, instance_id, query_id, query_text,
                   title, notes, tags, created_by, priority, status
            FROM pgconsole.query_bookmark
            WHERE id = ?
            """;

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setLong(1, id);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return mapBookmark(rs);
                }
            }
        } catch (SQLException e) {
            LOG.warnf("Failed to get bookmark %d: %s", id, e.getMessage());
        }

        return null;
    }

    /**
     * Retrieves a query bookmark by instance ID and query ID.
     * <p>
     * Since a query can only be bookmarked once per instance, this method
     * returns the unique bookmark for the given query on the specified instance.
     *
     * @param instanceId the database instance identifier
     * @param queryId the query identifier (typically MD5 hash of query text)
     * @return the bookmark, or null if not found
     */
    public QueryBookmark getByQueryId(String instanceId, String queryId) {
        String sql = """
            SELECT id, created_at, updated_at, instance_id, query_id, query_text,
                   title, notes, tags, created_by, priority, status
            FROM pgconsole.query_bookmark
            WHERE instance_id = ? AND query_id = ?
            """;

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, instanceId);
            stmt.setString(2, queryId);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return mapBookmark(rs);
                }
            }
        } catch (SQLException e) {
            LOG.warnf("Failed to get bookmark for query %s: %s", queryId, e.getMessage());
        }

        return null;
    }

    /**
     * Checks whether a query is bookmarked on the specified instance.
     *
     * @param instanceId the database instance identifier
     * @param queryId the query identifier
     * @return true if the query is bookmarked, false otherwise
     */
    public boolean isBookmarked(String instanceId, String queryId) {
        return getByQueryId(instanceId, queryId) != null;
    }

    /**
     * Retrieves all bookmarks for a specific database instance.
     *
     * @param instanceId the database instance identifier
     * @return list of all bookmarks for the instance, ordered by updated_at descending
     * @see #getBookmarks(String, String, String)
     */
    public List<QueryBookmark> getBookmarksForInstance(String instanceId) {
        return getBookmarks(instanceId, null, null);
    }

    /**
     * Retrieves bookmarks with optional filters.
     * <p>
     * Allows filtering by instance ID, status, and tag. Any filter parameter
     * may be null to skip that filter. Results are ordered by updated_at descending.
     *
     * @param instanceId the database instance identifier to filter by; null for all instances
     * @param status the bookmark status to filter by (e.g., "active", "investigating", "resolved"); null for all statuses
     * @param tag the tag to filter by; null to skip tag filtering
     * @return list of filtered bookmarks, ordered by updated_at descending
     */
    public List<QueryBookmark> getBookmarks(String instanceId, String status, String tag) {
        List<QueryBookmark> bookmarks = new ArrayList<>();

        StringBuilder sql = new StringBuilder("""
            SELECT id, created_at, updated_at, instance_id, query_id, query_text,
                   title, notes, tags, created_by, priority, status
            FROM pgconsole.query_bookmark
            WHERE 1=1
            """);

        List<Object> params = new ArrayList<>();

        if (instanceId != null && !instanceId.isEmpty()) {
            sql.append(" AND instance_id = ?");
            params.add(instanceId);
        }
        if (status != null && !status.isEmpty()) {
            sql.append(" AND status = ?");
            params.add(status.toLowerCase());
        }
        if (tag != null && !tag.isEmpty()) {
            sql.append(" AND ? = ANY(tags)");
            params.add(tag);
        }

        sql.append(" ORDER BY updated_at DESC");

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql.toString())) {

            for (int i = 0; i < params.size(); i++) {
                stmt.setObject(i + 1, params.get(i));
            }

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    bookmarks.add(mapBookmark(rs));
                }
            }
        } catch (SQLException e) {
            LOG.warnf("Failed to get bookmarks: %s", e.getMessage());
        }

        return bookmarks;
    }

    /**
     * Retrieves all unique tags used across bookmarks for a specific instance.
     * <p>
     * Flattens the tag arrays from all bookmarks and returns distinct values.
     * Useful for populating tag filter dropdowns or tag clouds.
     *
     * @param instanceId the database instance identifier
     * @return list of unique tags in alphabetical order
     */
    public List<String> getAllTags(String instanceId) {
        List<String> tags = new ArrayList<>();

        String sql = """
            SELECT DISTINCT UNNEST(tags) as tag
            FROM pgconsole.query_bookmark
            WHERE instance_id = ?
            ORDER BY tag
            """;

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, instanceId);

            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    tags.add(rs.getString("tag"));
                }
            }
        } catch (SQLException e) {
            LOG.warnf("Failed to get tags: %s", e.getMessage());
        }

        return tags;
    }

    /**
     * Retrieves summary statistics for bookmarks on a specific instance.
     * <p>
     * Provides aggregated counts by status (active, investigating, resolved)
     * and priority (critical, high). Useful for dashboard displays.
     *
     * @param instanceId the database instance identifier
     * @return bookmark summary statistics with counts by status and priority
     */
    public BookmarkSummary getSummary(String instanceId) {
        BookmarkSummary summary = new BookmarkSummary();

        String sql = """
            SELECT
                COUNT(*) as total,
                COUNT(*) FILTER (WHERE status = 'active') as active,
                COUNT(*) FILTER (WHERE status = 'investigating') as investigating,
                COUNT(*) FILTER (WHERE status = 'resolved') as resolved,
                COUNT(*) FILTER (WHERE priority = 'critical') as critical,
                COUNT(*) FILTER (WHERE priority = 'high') as high
            FROM pgconsole.query_bookmark
            WHERE instance_id = ?
            """;

        try (Connection conn = dataSource.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {

            stmt.setString(1, instanceId);

            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    summary.setTotalBookmarks(rs.getInt("total"));
                    summary.setActiveBookmarks(rs.getInt("active"));
                    summary.setInvestigatingBookmarks(rs.getInt("investigating"));
                    summary.setResolvedBookmarks(rs.getInt("resolved"));
                    summary.setCriticalBookmarks(rs.getInt("critical"));
                    summary.setHighPriorityBookmarks(rs.getInt("high"));
                }
            }
        } catch (SQLException e) {
            LOG.warnf("Failed to get bookmark summary: %s", e.getMessage());
        }

        return summary;
    }

    /**
     * Maps a ResultSet row to a QueryBookmark object.
     * <p>
     * This is a utility method used internally to convert database query results
     * into strongly-typed model objects. Handles PostgreSQL array conversion for tags.
     *
     * @param rs the ResultSet positioned at the row to map
     * @return populated QueryBookmark object
     * @throws SQLException if there is an error reading from the ResultSet
     */
    private QueryBookmark mapBookmark(ResultSet rs) throws SQLException {
        QueryBookmark bookmark = new QueryBookmark();
        bookmark.setId(rs.getLong("id"));
        bookmark.setCreatedAt(rs.getTimestamp("created_at").toInstant());
        bookmark.setUpdatedAt(rs.getTimestamp("updated_at").toInstant());
        bookmark.setInstanceId(rs.getString("instance_id"));
        bookmark.setQueryId(rs.getString("query_id"));
        bookmark.setQueryText(rs.getString("query_text"));
        bookmark.setTitle(rs.getString("title"));
        bookmark.setNotes(rs.getString("notes"));

        Array tagsArray = rs.getArray("tags");
        if (tagsArray != null) {
            String[] tags = (String[]) tagsArray.getArray();
            bookmark.setTags(Arrays.asList(tags));
        }

        bookmark.setCreatedBy(rs.getString("created_by"));
        bookmark.setPriorityFromString(rs.getString("priority"));
        bookmark.setStatusFromString(rs.getString("status"));

        return bookmark;
    }

    /**
     * Container for bookmark summary statistics.
     * <p>
     * Provides aggregated counts of bookmarks by status and priority,
     * useful for dashboard displays and monitoring.
     */
    public static class BookmarkSummary {
        private int totalBookmarks;
        private int activeBookmarks;
        private int investigatingBookmarks;
        private int resolvedBookmarks;
        private int criticalBookmarks;
        private int highPriorityBookmarks;

        public int getTotalBookmarks() { return totalBookmarks; }
        public void setTotalBookmarks(int value) { this.totalBookmarks = value; }

        public int getActiveBookmarks() { return activeBookmarks; }
        public void setActiveBookmarks(int value) { this.activeBookmarks = value; }

        public int getInvestigatingBookmarks() { return investigatingBookmarks; }
        public void setInvestigatingBookmarks(int value) { this.investigatingBookmarks = value; }

        public int getResolvedBookmarks() { return resolvedBookmarks; }
        public void setResolvedBookmarks(int value) { this.resolvedBookmarks = value; }

        public int getCriticalBookmarks() { return criticalBookmarks; }
        public void setCriticalBookmarks(int value) { this.criticalBookmarks = value; }

        public int getHighPriorityBookmarks() { return highPriorityBookmarks; }
        public void setHighPriorityBookmarks(int value) { this.highPriorityBookmarks = value; }
    }
}
