package com.bovinemagnet.pgconsole.model;

import java.time.Instant;

/**
 * Represents a point-in-time snapshot of system-level PostgreSQL metrics for historical tracking and trend analysis.
 * <p>
 * This model captures aggregated metrics across all databases in a PostgreSQL instance, including connection statistics,
 * query performance indicators, cache efficiency, and storage utilisation. Instances are typically sampled at regular
 * intervals (configured via {@code PG_CONSOLE_HISTORY_INTERVAL}) and stored in the {@code pgconsole.system_metrics_history}
 * table for generating sparklines and historical trends on the overview dashboard.
 * <p>
 * The metrics captured include:
 * <ul>
 * <li><b>Connection metrics:</b> Total connections, maximum allowed connections, active queries, idle connections,
 * and idle-in-transaction connections</li>
 * <li><b>Blocking metrics:</b> Number of blocked queries, longest running query duration, longest transaction duration</li>
 * <li><b>Cache metrics:</b> Buffer cache hit ratio (percentage of data served from memory vs. disk)</li>
 * <li><b>Storage metrics:</b> Total size of all databases in bytes</li>
 * </ul>
 * <p>
 * Historical records are automatically purged based on the retention period configured in
 * {@code PG_CONSOLE_HISTORY_RETENTION} (default: 7 days).
 *
 * @author Paul Snow
 * @since 0.0.0
 * @see com.bovinemagnet.pgconsole.service.MetricsSamplerService
 * @see com.bovinemagnet.pgconsole.repository.HistoryRepository
 */
public class SystemMetricsHistory {
    /**
     * Unique identifier for this metrics snapshot. Auto-generated by the database sequence.
     */
    private Long id;

    /**
     * The timestamp when this metrics snapshot was captured. Represents the exact point in time
     * when the PostgreSQL system views were queried to collect these metrics.
     */
    private Instant sampledAt;

    /**
     * Total number of database connections across all databases at the time of sampling.
     * Includes all connection states: active, idle, idle in transaction, etc.
     * <p>
     * Derived from {@code pg_stat_activity} by counting all non-null backend entries.
     */
    private int totalConnections;

    /**
     * Maximum number of concurrent connections allowed by the PostgreSQL server.
     * This is a configuration limit set by the {@code max_connections} parameter.
     * <p>
     * When {@code totalConnections} approaches this value, the server may reject new connection attempts.
     */
    private int maxConnections;

    /**
     * Number of connections actively executing queries at the time of sampling.
     * Excludes idle connections and connections idle in transaction.
     * <p>
     * Derived from {@code pg_stat_activity} by counting entries where {@code state = 'active'}
     * and the query is not the stats collector itself.
     */
    private int activeQueries;

    /**
     * Number of connections in the idle state (waiting for a new command from the client).
     * These connections are established but not currently executing any queries.
     * <p>
     * A high number of idle connections may indicate connection pooling inefficiency or
     * clients holding connections unnecessarily.
     */
    private int idleConnections;

    /**
     * Number of connections that are idle but still within an open transaction.
     * These connections have started a transaction but are not actively executing queries.
     * <p>
     * This is a critical metric as idle-in-transaction connections can hold locks, prevent
     * autovacuum from cleaning up dead rows, and cause database bloat. Prolonged idle-in-transaction
     * states often indicate application issues.
     * <p>
     * Derived from {@code pg_stat_activity} where {@code state = 'idle in transaction'}.
     */
    private int idleInTransaction;

    /**
     * Number of queries currently blocked and waiting for locks held by other transactions.
     * <p>
     * A non-zero value indicates lock contention in the database. Frequent or prolonged blocking
     * can significantly impact application performance and may require query or schema optimisation.
     * <p>
     * Derived from {@code pg_locks} by joining with {@code pg_stat_activity} to identify
     * queries waiting on locks.
     */
    private int blockedQueries;

    /**
     * Duration in seconds of the longest running query at the time of sampling.
     * May be {@code null} if no queries are active.
     * <p>
     * Long-running queries can indicate missing indexes, inefficient query plans, or queries
     * scanning large datasets. They may also hold locks and prevent other operations from completing.
     */
    private Double longestQuerySeconds;

    /**
     * Duration in seconds of the longest running transaction at the time of sampling.
     * May be {@code null} if no transactions are active.
     * <p>
     * Long-running transactions can prevent autovacuum from cleaning up dead tuples, leading
     * to table bloat and degraded query performance. They may also hold locks for extended periods.
     */
    private Double longestTransactionSeconds;

    /**
     * PostgreSQL buffer cache hit ratio, expressed as a percentage (0.0 to 100.0).
     * Represents the proportion of data blocks served from memory rather than requiring disk I/O.
     * <p>
     * A ratio above 95% is generally considered healthy. Lower values may indicate insufficient
     * {@code shared_buffers} configuration or queries scanning large amounts of data that don't
     * fit in the cache.
     * <p>
     * Calculated from {@code pg_stat_database} using the formula:
     * {@code (blks_hit / (blks_hit + blks_read)) * 100}
     */
    private Double cacheHitRatio;

    /**
     * Total size in bytes of all databases in the PostgreSQL instance.
     * Includes table data, indexes, and TOAST storage, but excludes WAL files and temporary files.
     * <p>
     * Calculated by summing {@code pg_database_size(datname)} for all non-template databases.
     */
    private Long totalDatabaseSizeBytes;

    /**
     * Returns the unique identifier for this metrics snapshot.
     *
     * @return the snapshot ID, or {@code null} if not yet persisted
     */
    public Long getId() {
        return id;
    }

    /**
     * Sets the unique identifier for this metrics snapshot.
     *
     * @param id the snapshot ID
     */
    public void setId(Long id) {
        this.id = id;
    }

    /**
     * Returns the timestamp when this metrics snapshot was captured.
     *
     * @return the sampling timestamp
     */
    public Instant getSampledAt() {
        return sampledAt;
    }

    /**
     * Sets the timestamp when this metrics snapshot was captured.
     *
     * @param sampledAt the sampling timestamp
     */
    public void setSampledAt(Instant sampledAt) {
        this.sampledAt = sampledAt;
    }

    /**
     * Returns the total number of database connections at the time of sampling.
     *
     * @return the total connection count
     */
    public int getTotalConnections() {
        return totalConnections;
    }

    /**
     * Sets the total number of database connections.
     *
     * @param totalConnections the total connection count
     */
    public void setTotalConnections(int totalConnections) {
        this.totalConnections = totalConnections;
    }

    /**
     * Returns the maximum number of concurrent connections allowed by the server.
     *
     * @return the maximum connection limit
     */
    public int getMaxConnections() {
        return maxConnections;
    }

    /**
     * Sets the maximum number of concurrent connections allowed by the server.
     *
     * @param maxConnections the maximum connection limit
     */
    public void setMaxConnections(int maxConnections) {
        this.maxConnections = maxConnections;
    }

    /**
     * Returns the number of connections actively executing queries.
     *
     * @return the active query count
     */
    public int getActiveQueries() {
        return activeQueries;
    }

    /**
     * Sets the number of connections actively executing queries.
     *
     * @param activeQueries the active query count
     */
    public void setActiveQueries(int activeQueries) {
        this.activeQueries = activeQueries;
    }

    /**
     * Returns the number of idle connections.
     *
     * @return the idle connection count
     */
    public int getIdleConnections() {
        return idleConnections;
    }

    /**
     * Sets the number of idle connections.
     *
     * @param idleConnections the idle connection count
     */
    public void setIdleConnections(int idleConnections) {
        this.idleConnections = idleConnections;
    }

    /**
     * Returns the number of connections that are idle within an open transaction.
     *
     * @return the idle-in-transaction connection count
     */
    public int getIdleInTransaction() {
        return idleInTransaction;
    }

    /**
     * Sets the number of connections that are idle within an open transaction.
     *
     * @param idleInTransaction the idle-in-transaction connection count
     */
    public void setIdleInTransaction(int idleInTransaction) {
        this.idleInTransaction = idleInTransaction;
    }

    /**
     * Returns the number of queries currently blocked waiting for locks.
     *
     * @return the blocked query count
     */
    public int getBlockedQueries() {
        return blockedQueries;
    }

    /**
     * Sets the number of queries currently blocked waiting for locks.
     *
     * @param blockedQueries the blocked query count
     */
    public void setBlockedQueries(int blockedQueries) {
        this.blockedQueries = blockedQueries;
    }

    /**
     * Returns the duration in seconds of the longest running query.
     *
     * @return the longest query duration in seconds, or {@code null} if no queries are active
     */
    public Double getLongestQuerySeconds() {
        return longestQuerySeconds;
    }

    /**
     * Sets the duration in seconds of the longest running query.
     *
     * @param longestQuerySeconds the longest query duration in seconds, or {@code null} if none
     */
    public void setLongestQuerySeconds(Double longestQuerySeconds) {
        this.longestQuerySeconds = longestQuerySeconds;
    }

    /**
     * Returns the duration in seconds of the longest running transaction.
     *
     * @return the longest transaction duration in seconds, or {@code null} if no transactions are active
     */
    public Double getLongestTransactionSeconds() {
        return longestTransactionSeconds;
    }

    /**
     * Sets the duration in seconds of the longest running transaction.
     *
     * @param longestTransactionSeconds the longest transaction duration in seconds, or {@code null} if none
     */
    public void setLongestTransactionSeconds(Double longestTransactionSeconds) {
        this.longestTransactionSeconds = longestTransactionSeconds;
    }

    /**
     * Returns the PostgreSQL buffer cache hit ratio as a percentage.
     *
     * @return the cache hit ratio (0.0 to 100.0), or {@code null} if not calculable
     */
    public Double getCacheHitRatio() {
        return cacheHitRatio;
    }

    /**
     * Sets the PostgreSQL buffer cache hit ratio as a percentage.
     *
     * @param cacheHitRatio the cache hit ratio (0.0 to 100.0)
     */
    public void setCacheHitRatio(Double cacheHitRatio) {
        this.cacheHitRatio = cacheHitRatio;
    }

    /**
     * Returns the total size of all databases in bytes.
     *
     * @return the total database size in bytes
     */
    public Long getTotalDatabaseSizeBytes() {
        return totalDatabaseSizeBytes;
    }

    /**
     * Sets the total size of all databases in bytes.
     *
     * @param totalDatabaseSizeBytes the total database size in bytes
     */
    public void setTotalDatabaseSizeBytes(Long totalDatabaseSizeBytes) {
        this.totalDatabaseSizeBytes = totalDatabaseSizeBytes;
    }
}
